## 1. JavaScript Execution Model(Foundational Context)

JavaScript executes code using a ** single - threaded execution model **, meaning only ** one piece of JavaScript code can run at a time **.This single thread is responsible for:

* executing synchronous code
    * handling function calls
* running callbacks
    * updating the UI

Despite being single - threaded, JavaScript can handle ** asynchronous operations ** efficiently through cooperation with the browser or runtime environment.This cooperation is coordinated by the ** Event Loop **.

    Understanding ** events and the event loop ** requires understanding how JavaScript separates ** execution ** from ** waiting **.

---

## 2. What Are Events ?

    An ** event ** is a notification that something has happened in the system.Events are generated by the browser or runtime environment, not by JavaScript itself.

Common sources of events include:

* user interactions(click, keypress, scroll)
    * timers completing
        * network requests finishing
            * DOM mutations
                * media playback
                    * page lifecycle changes

Events do not execute code immediately.Instead, they ** schedule callbacks ** to be executed later when JavaScript is ready.

---

## 3. Event Handlers and Event Registration

JavaScript reacts to events by registering ** event listeners **.

```javascript
button.addEventListener("click", function () {
  console.log("Clicked")
})
```

When this code runs:

* the callback is registered with the browser’s event system
    * JavaScript does not pause or wait
        * execution continues immediately

When the event occurs:

* the browser places the callback into a queue
    * the callback waits until the JavaScript call stack is empty

---

## 4. The Call Stack

The ** Call Stack ** is the data structure where JavaScript executes functions.

    Characteristics:

* LIFO(Last In, First Out)
    * contains execution contexts
        * only one stack exists
            * only one function runs at a time

Example:

```javascript
function a() {
  b()
}
function b() {
  c()
}
function c() {
  console.log("Hello")
}
a()
```

Call stack progression:

```
push a()
push b()
push c()
pop c()
pop b()
pop a()
```

If the call stack is busy, ** no other JavaScript can run **.

---

## 5. Why Asynchronous Handling Is Needed

Operations such as:

* waiting for a timer
    * fetching data from a server
        * waiting for user input

can take an unknown amount of time.If JavaScript waited synchronously for these operations, the page would freeze.

To avoid blocking:

* JavaScript ** delegates ** these tasks to the environment
    * execution continues immediately
        * results are handled later

This delegation is handled by ** Web APIs **.

---

## 6. Web APIs(Browser or Runtime Environment)

    ** Web APIs ** are features provided by the browser(or Node.js) that run outside the JavaScript engine.

        Examples:

* setTimeout / setInterval
    * DOM event handling
        * fetch / XMLHttpRequest
        * geolocation
        * File APIs
            * MutationObserver

When JavaScript calls a Web API:

* the request is registered
    * JavaScript continues execution
        * when the operation completes, a callback is scheduled

---

## 7. Task Queue(Macro Task Queue)

The ** Task Queue ** stores callbacks from:

* setTimeout
    * setInterval
    * DOM events(click, input, etc.)
        * message events
            * older async APIs

These callbacks are also called ** macrotasks **.

They do not execute immediately.They wait until:

* the call stack is empty
    * all microtasks are completed

---

## 8. Microtask Queue

The ** Microtask Queue ** is a higher - priority queue used for:

* Promise`.then()` and`.catch()`
    * async / await continuations
    * MutationObserver callbacks
        * `queueMicrotask()`

Rules:

* microtasks always run ** before ** macrotasks
    * all microtasks are executed before the event loop moves on

---

## 9. The Event Loop(Core Mechanism)

The ** Event Loop ** is a continuous process that coordinates execution.

Its responsibilities:

1. Monitor the call stack
2. When the stack is empty:

   * execute all microtasks
3. After microtasks:

   * execute one macrotask from the task queue
4. Repeat indefinitely

The event loop itself does ** not execute code **.It decides ** when code is allowed to execute **.

---

## 10. Event Loop Diagram(Execution Flow)

    ```
        ┌───────────────────┐
        │   Call Stack      │
        └─────────▲─────────┘
                  │
        ┌─────────┴─────────┐
        │    Event Loop     │
        └─────────▲─────────┘
                  │
     ┌────────────┴────────────┐
     │      Microtask Queue    │
     │ (Promises, async/await) │
     └────────────▲────────────┘
                  │
     ┌────────────┴────────────┐
     │        Task Queue       │
     │ (Timers, DOM events)    │
     └────────────▲────────────┘
                  │
        ┌─────────┴─────────┐
        │     Web APIs      │
        └───────────────────┘
```

---

## 11. Memory Perspective Diagram

    ```
STACK (Execution)
-----------------
global()
function calls
local variables
references

HEAP (Memory)
--------------
objects
closures
functions
DOM nodes

QUEUES
-------
microtasks
macrotasks
```

---

## 12. Comparing Async Behaviors(Essential Examples)

### Example 1: Synchronous vs Asynchronous

    ```javascript
console.log("A")
setTimeout(() => console.log("B"), 0)
console.log("C")
```

Execution:

* synchronous code runs first
    * timeout callback goes to task queue

Output:

```
A
C
B
```

---

### Example 2: Promise vs setTimeout

    ```javascript
console.log("A")

setTimeout(() => console.log("Timeout"), 0)

Promise.resolve().then(() => console.log("Promise"))

console.log("B")
```

Execution order:

1. synchronous code
2. microtasks
3. macrotasks

Output:

```
A
B
Promise
Timeout
```

---

### Example 3: Nested Microtasks

    ```javascript
Promise.resolve().then(() => {
  console.log("First")
  Promise.resolve().then(() => console.log("Second"))
})
```

Output:

```
First
Second
```

Microtasks created inside microtasks are executed ** before ** moving to macrotasks.

---

### Example 4: Async / Await Behavior

    ```javascript
async function test() {
  console.log("A")
  await Promise.resolve()
  console.log("B")
}

console.log("Start")
test()
console.log("End")
```

Explanation:

* `await` pauses function execution
* continuation is scheduled as a microtask

Output:

```
Start
A
End
B
```

---

### Example 5: DOM Event vs Promise

    ```javascript
button.addEventListener("click", () => console.log("Click"))

Promise.resolve().then(() => console.log("Promise"))
```

If click happens:

* Promise callback runs first
    * Click handler runs later

Reason:

* Promises use microtask queue
    * DOM events use task queue

---

## 13. Why the Event Loop Is Essential

The event loop enables:

* non - blocking I / O
    * responsive UI
        * concurrency without multithreading
            * predictable execution order
                * safe DOM manipulation

Without the event loop:

* JavaScript would block on I / O
    * the browser would freeze
        * async programming would not exist

